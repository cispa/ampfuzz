import re

import pysmt.fnode
import pysmt.operators as ops
from pysmt.exceptions import PysmtSyntaxError
from pysmt.shortcuts import *
from pysmt.smtlib.parser import SmtLibZ3Parser, Tokenizer

from logparser import LogParser

template = """# Autogenerated by AmpFuzz
class {classname}{port}Handler:
    \"""
    AmpFuzz generated handler for {name}, listening on port {port}.
    \"""
    NAME = "{name}_{port}"
    PORT = {port}

    def _get_response_payload(self, request):
        return gen_reply(request)

{code}
"""

MAX_COMPLEX = 1

def complexity(expr):
    return sum(complexity(a) for a in expr.args()) + 1 if len(expr.args()) > 1 else 0


# Z3 special operators...
REPLACEMENTS = {
    "bvsdiv0": "bvsdiv",
    "bvudiv0": "bvudiv",
    "bvsrem0": "bvsrem",
    "bvurem0": "bvurem",
    "bvsmod0": "bvsmod",
    "bvsdiv_i": "bvsdiv",
    "bvudiv_i": "bvudiv",
    "bvsrem_i": "bvsrem",
    "bvurem_i": "bvurem",
    "bvsmod_i": "bvsmod",
}


class CustomSmtLibParser(SmtLibZ3Parser):
    def get_expression(self, tokens):
        """
        Returns the pysmt representation of the given parsed expression
        """
        mgr = self.env.formula_manager
        stack = []

        try:
            while True:
                tk = tokens.consume_maybe()

                if tk == "(":
                    while tk == "(":
                        stack.append([])
                        tk = tokens.consume()

                    if tk in self.interpreted:
                        fun = self.interpreted[tk]
                        fun(stack, tokens, tk)
                    else:
                        stack[-1].append(self.atom(tk, mgr))

                elif tk == ")":
                    try:
                        lst = stack.pop()
                        fun = lst.pop(0)
                    except IndexError:
                        raise PysmtSyntaxError("Unexpected ')'",
                                               tokens.pos_info)

                    try:
                        res = fun(*lst)
                    except TypeError as err:
                        if not callable(fun):
                            raise NotImplementedError("Unknown function '%s'" % fun)
                        import inspect
                        n_args = len(inspect.signature(fun).parameters)
                        res = fun(*lst[:n_args])
                        for i in range(n_args, len(lst)):
                            res = fun(*lst[:n_args - 2], res, lst[i])

                    if len(stack) > 0:
                        stack[-1].append(res)
                    else:
                        return res

                else:
                    try:
                        stack[-1].append(self.atom(tk, mgr))
                    except IndexError:
                        return self.atom(tk, mgr)
        except StopIteration:
            # No more data when trying to consume tokens
            return


def cleanup(expr):
    for old, new in REPLACEMENTS.items():
        expr = expr.replace(old, new)
    return expr


def _assert_bv_width(expr, bv_width):
    return f'({expr}) & {hex((1 << bv_width) - 1)}'


def to_python(expr, simplify=False, name='f', input_prefixes=['pkt_in']):
    assert type(expr) == pysmt.fnode.FNode
    if simplify:
        expr = expr.simplify()

    gen = ExprGenerator(input_prefixes=input_prefixes)
    return gen.generate(expr, name=name)


def to_python_bytes(expr_list, simplify=False, name='f', input_prefixes=['pkt_in']):
    for expr in expr_list:
        assert type(expr) == pysmt.fnode.FNode
    if simplify:
        expr_list = [expr.simplify() for expr in expr_list]

    gen = ExprGenerator(input_prefixes=input_prefixes)
    return gen.generate_bytes(expr_list, name=name)


class ExprGenerator:
    def __init__(self, input_prefixes):
        self.r = 0
        self.stmts = []
        self.inv_map = dict()
        self.input_prefixes = input_prefixes

    def generate(self, expr, name='f'):
        signature, max_idxs = self._get_signature([expr])
        self.stmts = [f'def {name}{signature}:']
        for prefix, idx in max_idxs.items():
            self.stmts.append(f'if len({prefix}) < {idx + 1}:')
            self.stmts.append('    return False')
        pyexpr = self._to_python(expr)
        self.stmts.append(f'return {pyexpr}')
        return '\n    '.join(self.stmts)

    def generate_bytes(self, exprs, name='f'):
        signature, max_idxs = self._get_signature(exprs)
        self.stmts = [f'def {name}{signature}:']
        for prefix, idx in max_idxs.items():
            self.stmts.append(f'if len({prefix}) < {idx + 1}:')
            self.stmts.append('    return False')
        pyexprs = [self._to_python(expr) for expr in exprs]
        self.stmts.append(f'return bytes([{", ".join(pyexprs)}])')
        return '\n    '.join(self.stmts)

    def _reg(self):
        r = self.r
        self.r += 1
        return f'r{r}'

    def _to_python(self, expr):
        pyexpr = self._expr_to_expr(expr)
        if complexity(expr) < MAX_COMPLEX:
            if len(expr.args()) > 0 or '&' in pyexpr:
                pyexpr = f"({pyexpr})"
            return pyexpr
        if pyexpr in self.inv_map:
            r = self.inv_map[pyexpr]
        else:
            r = self._reg()
            self.inv_map[pyexpr] = r
            self.stmts.append(f'{r} = {pyexpr}')
        return r

    def _expr_to_expr(self, expr):
        expr_type = expr.node_type()

        # Boolean Logic (0-6)
        if expr_type == ops.FORALL:
            raise ValueError("quantifiers not supported")
        elif expr_type == ops.EXISTS:
            raise ValueError("quantifiers not supported")
        elif expr_type == ops.AND:
            return ' and '.join(self._to_python(c) for c in expr.args())
        elif expr_type == ops.OR:
            return ' or '.join(self._to_python(c) for c in expr.args())
        elif expr_type == ops.NOT:
            assert len(expr.args()) == 1
            return 'not ' + self._to_python(expr.arg(0))
        elif expr_type == ops.IMPLIES:
            assert len(expr.args()) == 2
            return '(not ' + self._to_python(expr.arg(0)) + ') or ' + self._to_python(expr.arg(1))
        elif expr_type == ops.IFF:
            assert len(expr.args()) == 2
            return self._to_python(expr.arg(0)) + ' == ' + self._to_python(expr.arg(1))
        # Symbols and functions calls (7-8)
        elif expr_type == ops.SYMBOL:

            symbol_name = expr.symbol_name()
            is_input_arr = False
            if symbol_name.startswith('length_'):
                symbol_name = f'len({symbol_name[7:]})'
            else:
                for prefix in self.input_prefixes:
                    m = re.match(rf"{prefix}(?P<idx>[0-9]+)", symbol_name)
                    if m:
                        symbol_name = f"{prefix}[{m['idx']}]"
                        is_input_arr = True
                        break

            if expr.symbol_type().is_bv_type() and (not is_input_arr or expr.bv_width() != 8):
                return _assert_bv_width(symbol_name, expr.bv_width())
            else:
                return symbol_name
        elif expr_type == ops.FUNCTION:
            raise ValueError("functions not supported")

        # Constants (9-12)
        elif expr_type == ops.REAL_CONSTANT:
            return repr(float(expr.constant_value()))
        elif expr_type == ops.BOOL_CONSTANT:
            return repr(expr.constant_value())
        elif expr_type == ops.INT_CONSTANT:
            return repr(expr.constant_value())
        elif expr_type == ops.STR_CONSTANT:
            return repr(expr.constant_value())

        # LIA/LRA operators (13-15)
        elif expr_type == ops.PLUS:
            return ' + '.join(self._to_python(c) for c in expr.args())
        elif expr_type == ops.MINUS:
            return ' - '.join(self._to_python(c) for c in expr.args())
        elif expr_type == ops.TIMES:
            return ' * '.join(self._to_python(c) for c in expr.args())

        # LIA/LRA relations (16-18)
        elif expr_type == ops.LE:
            assert len(expr.args()) == 2
            return self._to_python(expr.arg(0)) + ' <= ' + self._to_python(expr.arg(1))
        elif expr_type == ops.LT:
            return self._to_python(expr.arg(0)) + ' < ' + self._to_python(expr.arg(1))
        elif expr_type == ops.EQUALS:
            return self._to_python(expr.arg(0)) + ' == ' + self._to_python(expr.arg(1))

        # Term-ite (19)
        elif expr_type == ops.ITE:
            arg_if = self._to_python(expr.arg(0))
            arg_then = self._to_python(expr.arg(1))
            arg_else = self._to_python(expr.arg(2))
            return f"{arg_then} if {arg_if} else {arg_else}"

        # LIRA toreal() function (20)
        elif expr_type == ops.TOREAL:
            assert len(expr.args()) == 1
            return 'float(' + self._to_python(expr.arg(0)) + ')'


        # BV
        # Bit-Vector constant (21)
        elif expr_type == ops.BV_CONSTANT:
            return hex(expr.constant_value())
        # Logical Operators on Bit (22-25)
        elif expr_type == ops.BV_NOT:
            assert len(expr.args()) == 1
            return _assert_bv_width('~' + self._to_python(expr.arg(0)), expr.bv_width())
        elif expr_type == ops.BV_AND:
            return _assert_bv_width(' & '.join(self._to_python(c) for c in expr.args()), expr.bv_width())
        elif expr_type == ops.BV_OR:
            return _assert_bv_width(' | '.join(self._to_python(c) for c in expr.args()), expr.bv_width())
        elif expr_type == ops.BV_XOR:
            return _assert_bv_width(' ^ '.join(self._to_python(c) for c in expr.args()), expr.bv_width())
        # BV Concatenation (26)
        elif expr_type == ops.BV_CONCAT:
            assert len(expr.args()) == 2
            # no need for length-check, value cannot exceed bounds
            return '(' + self._to_python(expr.arg(0)) + '<<' + repr(expr.arg(1).bv_width()) + ')|' + self._to_python(
                expr.arg(1))
        # BV sub-vector extraction (27)
        elif expr_type == ops.BV_EXTRACT:
            extract_start = expr.bv_extract_start()
            extracted = self._to_python(expr.arg(0)) + (('>>' + repr(extract_start)) if extract_start > 0 else '')
            return _assert_bv_width(extracted, expr.bv_width())
        # Unsigned Comparison (28-29)
        elif expr_type == ops.BV_ULT:
            return self._to_python(expr.arg(0)) + ' < ' + self._to_python(expr.arg(1))
        elif expr_type == ops.BV_ULE:
            return self._to_python(expr.arg(0)) + ' <= ' + self._to_python(expr.arg(1))
        # Basic arithmetic (30-32)
        elif expr_type == ops.BV_NEG:
            assert len(expr.args()) == 1
            return _assert_bv_width('-' + self._to_python(expr.arg(0)), expr.bv_width())
        elif expr_type == ops.BV_ADD:
            return _assert_bv_width(' + '.join(self._to_python(c) for c in expr.args()), expr.bv_width())
        elif expr_type == ops.BV_SUB:
            return _assert_bv_width(' - '.join(self._to_python(c) for c in expr.args()), expr.bv_width())
        # Division/Multiplication (33-35)
        elif expr_type == ops.BV_MUL:
            return _assert_bv_width(' * '.join(self._to_python(c) for c in expr.args()), expr.bv_width())
        elif expr_type == ops.BV_UDIV:
            return _assert_bv_width(' // '.join(self._to_python(c) for c in expr.args()), expr.bv_width())
        elif expr_type == ops.BV_UREM:
            return _assert_bv_width(' % '.join(self._to_python(c) for c in expr.args()), expr.bv_width())
        # Shifts (36-37)
        elif expr_type == ops.BV_LSHL:
            return _assert_bv_width(' << '.join(self._to_python(c) for c in expr.args()), expr.bv_width())
        elif expr_type == ops.BV_LSHR:
            return _assert_bv_width(' >> '.join(self._to_python(c) for c in expr.args()), expr.bv_width())
        # Rotation (38-39)
        elif expr_type == ops.BV_ROL:
            assert len(expr.args()) == 1
            steps_left = expr.bv_rotation_step()
            steps_right = expr.bv_width() - steps_left
            py_expr = self._to_python(expr.arg(0))
            return _assert_bv_width(
                '(' + py_expr + '<<' + repr(steps_left) + ')|(' + py_expr + '>>' + repr(steps_right) + ')',
                expr.bv_width())
        elif expr_type == ops.BV_ROR:
            assert len(expr.args()) == 1
            steps_right = expr.bv_rotation_step()
            steps_left = expr.bv_width() - steps_right
            py_expr = self._to_python(expr.arg(0))
            return _assert_bv_width(
                '(' + py_expr + '<<' + repr(steps_left) + ')|(' + py_expr + '>>' + repr(steps_right) + ')',
                expr.bv_width())
        # Extension (40-41)
        elif expr_type == ops.BV_ZEXT:
            assert len(expr.args()) == 1
            # no need to change anything,  wider width will be check by higher expressions
            return self._to_python(expr.arg(0))
        elif expr_type == ops.BV_SEXT:
            assert len(expr.args()) == 1
            return _assert_bv_width(self._to_signed(expr.arg(0)), expr.bv_width())
        # Signed Comparison (42-43)
        elif expr_type == ops.BV_SLT:
            return self._to_signed(expr.arg(0)) + ' < ' + self._to_signed(expr.arg(1))
        elif expr_type == ops.BV_SLE:
            return self._to_signed(expr.arg(0)) + ' <= ' + self._to_signed(expr.arg(1))

        # Returns 1_1 if the arguments are
        # equal otherwise it returns 0_1 (44)
        elif expr_type == ops.BV_COMP:
            return f'int({self._to_python(expr.arg(0))} == {self._to_python(expr.arg(1))})'

        # Signed Division and Reminder(45-46)
        elif expr_type == ops.BV_SDIV:
            return _assert_bv_width(' // '.join(self._to_signed(c) for c in expr.args()), expr.bv_width())
        elif expr_type == ops.BV_SREM:
            return _assert_bv_width(' % '.join(self._to_signed(c) for c in expr.args()), expr.bv_width())

        # Arithmetic shift right (47)
        elif expr_type == ops.BV_ASHR:
            return _assert_bv_width(f'{self._to_signed(expr.arg(0))} >> {self._to_python(expr.arg(1))}',
                                    expr.bv_width())

        #
        # STRINGS
        #
        # Length (48)
        elif expr_type == ops.STR_LENGTH:

            return f'len({self._to_python(expr.arg(0))})'

        # Concat (49)
        elif expr_type == ops.STR_CONCAT:
            return ' + '.join(self._to_python(c) for c in expr.args())

        # Contains (50)
        elif expr_type == ops.STR_CONTAINS:
            return ' in '.join(self._to_python(c) for c in expr.args())

        # IndexOf (51)
        elif expr_type == ops.STR_INDEXOF:
            raise NotImplementedError('STR_INDEXOF')

        # Replace (52)
        elif expr_type == ops.STR_REPLACE:
            raise NotImplementedError('STR_REPLACE')

        # Sub String (53)
        elif expr_type == ops.STR_SUBSTR:
            raise NotImplementedError('STR_SUBSTR')

        # Prefix (54)
        elif expr_type == ops.STR_PREFIXOF:
            raise NotImplementedError('STR_PREFIXOF')

        # Suffix (55)
        elif expr_type == ops.STR_SUFFIXOF:
            raise NotImplementedError('STR_SUFFIXOF')

        # atoi (56)
        elif expr_type == ops.STR_TO_INT:
            return f'int({self._to_python(expr.arg(0))})'

        # itoa (57)
        elif expr_type == ops.INT_TO_STR:
            return f'str({self._to_python(expr.arg(0))})'

        # Char at an index (58)
        elif expr_type == ops.STR_CHARAT:
            raise NotImplementedError('STR_CHARAT')

        #
        # ARRAYS
        #
        # Array Select (59)
        elif expr_type == ops.ARRAY_SELECT:
            raise NotImplementedError('ARRAY_SELECT')

        # Array Store (60)
        elif expr_type == ops.ARRAY_STORE:
            raise NotImplementedError('ARRAY_STORE')

        # Array Value (61)
        elif expr_type == ops.ARRAY_VALUE:
            raise NotImplementedError('ARRAY_VALUE')

        # Arithmetic Division (62)
        elif expr_type == ops.DIV:
            raise NotImplementedError('DIV')

        # Arithmetic Power (63)
        elif expr_type == ops.POW:
            raise NotImplementedError('POW')

        # Algebraic Number (64)
        elif expr_type == ops.ALGEBRAIC_CONSTANT:
            raise NotImplementedError('ALGEBRAIC_CONSTANT')

        # BV to Natural Conversion (65)
        elif expr_type == ops.BV_TONATURAL:
            raise NotImplementedError('BV_TONATURAL')

        raise ValueError("Unknown expression")

    def _get_signature(self, exprs):
        symbol_names = set(self.input_prefixes)
        max_idxs = {}
        for expr in exprs:
            for v in expr.get_free_variables():
                symbol_name = v.symbol_name()
                if symbol_name.startswith('length_'):
                    symbol_names.add(symbol_name[7:])
                else:
                    for prefix in self.input_prefixes:
                        if symbol_name.startswith(prefix):
                            symbol_names.add(prefix)
                            idx = int(symbol_name[len(prefix):])
                            max_idxs[prefix] = max(idx, max_idxs.get(prefix, 0))
                            break
                    else:
                        symbol_names.add(symbol_name)
        return '(' + ', '.join(sorted(symbol_names)) + ')', max_idxs

    def _to_signed(self, expr):
        inner_pyexpr = self._to_python(expr)
        w = 1 << (expr.bv_width() - 1)
        shifted_pyexpr = _assert_bv_width(f'({inner_pyexpr}) + {hex(w)}', expr.bv_width())
        pyexpr = f'({shifted_pyexpr}) - {hex(w)}'
        if pyexpr in self.inv_map:
            r = self.inv_map[pyexpr]
        else:
            r = self._reg()
            self.inv_map[pyexpr] = r
            self.stmts.append(f'{r} = {pyexpr}')
        return r


def parse_expr(expr, input_prefixes=['pkt_in']):
    import io
    import re

    expr = cleanup(expr)

    all_vars = set()
    all_lens = set()
    for prefix in input_prefixes:
        all_vars.update(re.findall(rf'{prefix}[0-9]+', expr))
        all_lens.update(re.findall(rf'length_{prefix}', expr))

    #                                                       assuming a 64-bit system here...
    all_syms = [Symbol(v, BVType(8)) for v in all_vars] + [Symbol(v, BVType(64)) for v in all_lens]

    parser = CustomSmtLibParser()
    for sym in all_syms:
        parser.cache.bind(sym.symbol_name(), sym)
    return parser.get_expression(Tokenizer(io.StringIO(expr)))


def generate_honeypot_function(lines):
    p = LogParser(lines)
    check_out = []
    output_lines = []
    for i, (constraints, output) in enumerate(p.parse()):
        total_constraints = '(and ' + ' '.join(constraints) + ')'
        total_path = parse_expr(total_constraints)
        output_lines.append(to_python(total_path, simplify=True, name=f'check{i}'))
        output_lines.append('')

        output_exprs = [parse_expr(f"(+ {output_byte.strip()})") for output_byte in output]
        output_lines.append(to_python_bytes(output_exprs, simplify=True, name=f'output{i}'))
        output_lines.append('')
        check_out.append((f'check{i}', f'output{i}'))
    output_lines.append('def gen_reply(pkt_in):')
    for check, output in check_out:
        output_lines.append(f'    if {check}(pkt_in):')
        output_lines.append(f'        return {output}(pkt_in)')
    return ''.join(f'{line}\n' for line in output_lines)


def main():
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('input', help='Input file with symbolic constraints')
    parser.add_argument('name', help='name of handler')
    parser.add_argument('port', help='input port')
    args = parser.parse_args()

    with open(args.input) as f:
        lines = f.read().splitlines()

    code = generate_honeypot_function(lines)
    print(template.format(code=code, classname=''.join(x.capitalize() for x in args.name.split('_')), name=args.name, port=args.port))


if __name__ == '__main__':
    main()
